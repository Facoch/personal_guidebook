% =================================================================================================
% File:			all.tex
% Description:	Defiinisce la sezione relativa a ...
% Created:		2015-01-29
% Author:		Tesser Paolo
% Email:		p.tesser921@gmail.com
% =================================================================================================
% Modification History:
% Version		Modifier Date		Change												Author
% 0.0.1 		2015-01-29 			iniziata stesura documento di prova					Tesser Paolo
% =================================================================================================
% 0.0.2			2015-02-02			aggiunta img + migliorata sez. configurazioni		Tesser Paolo
% =================================================================================================
% 0.0.3			2015-02-02			aggiunta sezione per i workflow, da stendere		Tesser Paolo
% =================================================================================================
% 0.0.4			2015-02-03			commentate due parti di codice (verbatim) per bug	Tesser Paolo
% =================================================================================================
% 0.0.5			2015-02-03			aggiunto comando line 21 per fix bug (solo su git)	Tesser Paolo
% =================================================================================================
% 0.0.6			2015-02-03			stesura sezione sui tips per velocizzare lavoro		Tesser Paolo
% =================================================================================================
%

\global\let\tikz@ensure@dollar@catcode=\relax % fix verbatim PROBLEM

% CONTENUTO DEL CAPITOLO

\section{Introduzione} % (fold)
\label{sec:introduzione}
Git è un sistema di controllo di versione distribuito.
\newline
\textbf{Distribuito} (DVCS) significa che ogni componente, del gruppo di lavoro, possiede una copia locale completa del repository.
\newline

\noindent
\textbf{Vantaggi}:
	\begin{itemize}
		\item operazioni di commit più veloci da effettuare;
		\item si riesce a lavorare offline;
		\item ognuno ha in locale un backup del repository.
	\end{itemize}
	\noindent
	\newline
La seguente immagine serve per dare un idea generale di come git lavori e tramite quali operazioni di base. Viene mostrato inoltre il rapporto tra la gestione in locale del repository con quello in remoto. Il dettaglio delle operazioni sarà illustrato prevalentemente nella sezione \ref{sec:lavorare_sul_repository}.

	\begin{figure}[htbp]
		\centering
		\includegraphics[scale=1.1]{images/git_local_remote.png}
		\caption{Git - Locale e Remoto}
		\label{fig:git_locale_e_remoto}
	\end{figure}


	\subsection{Informativi} % (fold)
	\label{sub:informativi}
		\begin{itemize}
			\item \textbf{CodeSchool}: \url{www.codeschool.com};
			\item \textbf{CERN - Best Practice}: PDF;
		\end{itemize}
	% subsection informativi (end)

% section introduzione (end)

\newpage \clearpage
\section{Riferimenti} % (fold)
\label{sec:riferimenti}
Di seguito viene spiegato attraverso quali nomi git si riferisce a determinati stati del versionamento. \newline \newline

\textbf{Riferimenti specifici}:
	\begin{itemize}
		\item \textbf{Working Tree}: è l'insieme di file su cui si sta lavorando non ancora aggiunti alla staging area (vedi sezione \ref{sub:lavorare_in_locale});
		\item \textbf{Index}: è il riferimento ai file pronti per essere committati, quelli aggiunti alla staging area;
		\item \textbf{HEAD}: è il riferimento all'ultimo commit effettuato;
		\item \textbf{d3a7c852d2c789f791b11091894cc71387e562e9}: un valore hash attribuito ad ogni commit;
		\item \textbf{master, feature-eg}: il nome esatto di un branch per riferirsi ad esso;
		\item \textbf{v1.0.0}: il nome di un tag per riferirsi ad esso.
	\end{itemize}
	\noindent
\textbf{Riferimenti relativi}:
\begin{comment}
	\begin{itemize}
		\item il commit precedente: ref\textasciitilde1 oppure ref^;
		\item il penultimo commit: ref\textasciitilde2 oppure ref^^;
		\item genitori differenti: ref^1. (TO LEARN).
	\end{itemize}
\end{comment}

% section riferimenti (end)


\newpage \clearpage
\section{Impostare git} % (fold)
\label{sec:impostare_git}
La prima volta che si installa git è buona pratica impostare da subito alcune credenziali. \newline
Queste credenziali possono essere impostate su diversi livelli:
	\begin{itemize}
		\item \textbf{global}: valide quindi per tutti i repository dell'utente. Si trovano nel file:
			\begin{center}
				~/.gitconfig
			\end{center}
		\item \textbf{system}: valide per tutti i repository del computer. Si trovano nel file:
			\begin{center}
				/etc/gitconfig
			\end{center}
		\item \textbf{local}: valide solo per il repository dal quale vengono impostate. Si trovano nel file:
			\begin{center}
				.git/config
			\end{center}
	\end{itemize}
Da linea di comando eseguire i seguenti comandi, cambiando l'opzione ``global'' a seconda delle esigenze:
	\begin{verbatim}
	path: git config --global user.name "Nome Cognome"
	path: git config --global user.email mail@mail.com
	path: git config --global color.ui true
	path: git config --global core.editor emacs
	path: git config --global commit.template ~/.gitmessage.txt
	\end{verbatim}

% section impostare_git (end)

\newpage \clearpage
\section{Creare un repository} % (fold)
\label{sec:creare_un_repository}
Un repository può essere creato in locale e usato solo nel computer dell'utente, anche se questo non permetterà un lavoro collaborativo, oppure, dopo la creazione in locale, può essere associato ad un repository creato su un server (o attraverso un servizio di hosting). \newline
Per creare un repository su un servizio di hosting basta seguire le istruzione che il sito propone.
	\subsection{Creazione in locale} % (fold)
	\label{sub:creazione_in_locale}
	Di seguito viene illustrata la sequenza di comandi che dovranno essere eseguiti:
		\begin{verbatim}
		path: mkdir nome_repo
		path: cd nome_repo
		path: git init
		\end{verbatim}
	\noindent
	L'ultima istruzione creerà tutti i metadati necessari al repository. Verranno salvati nella cartella nascosta:
		\begin{center}
			nome\_repo/.git/
		\end{center}

	% subsection creazione_in_locale (end)
	
% section creare_un_repository (end)

\newpage \clearpage
\section{Lavorare sul repository} % (fold)
\label{sec:lavorare_sul_repository}

	\subsection{Lavorare in locale} % (fold)
	\label{sub:lavorare_in_locale}
	Le tre azioni che vengono più spesso eseguite quando si lavora in locale sono:
		\begin{itemize}
			\item creare un file;
			\item aggiungerlo alla \textbf{staging area} attraverso il comando:
				\begin{verbatim}
				path: git add nome_del_file.ext
				\end{verbatim}
				\noindent
				La staging area è il luogo dove sono presenti i file pronti per essere committati.
				Se si vogliono aggiungere più file contemporaneamente o solo alcuni, possiamo eseguire in esclusione questi comandi:
					\begin{verbatim}
					# aggiunge tutti i file presenti nella unstaging area
					path: git add --all
					path: git add <list of file>
					path: git add *.ext
					path: git add dir/
					\end{verbatim}
				\noindent
				\textbf{Buona pratica}, come verrà illustrato di seguito, vuole che i commit siano il più possibile atomici. \'E \textbf{consigliato fortemente} quindi eseguire il comando:
					\begin{verbatim}
					path: git add --patch (o -p)
					\end{verbatim}
				\noindent
				Questo comando permettere di revisionare il codice che si sta aggiungendo, con la possibilità di scartarne delle parti;

			\item committare i cambiamenti attraverso il comando:
				\begin{verbatim}
				path: git commit -m "msg"
				\end{verbatim}
				\noindent
				Quest'ultima operazione può essere effettuata anche senza l'opzione -m, in tal caso la procedura seguirà lo schema illustrato nella sezione TO DO; \newline
				Importante e \textbf{obbligatorio} è effettuare commit atomici in quanto se qualcosa andasse storto, per colpa di qualche inserimento sbagliato, sarebbe più facile effettuare una ricerca dell'errore. Inoltre, questa metodologia, permette di dare una descrizione più efficace sul messaggio di cosa si sta facendo e soprattutto meno prolissa in quanto vado ad aggiungere meno cose contemporaneamente. \newline
				Il messaggio che viene inserito deve essere di facile interpretazione. Non bisogna scrivere cose generiche o superflue.
				 
		\end{itemize}
	\noindent
	Per osservare i cambiamenti avvenuti dall'ultima operazione di commit basta lanciare il comando:
		\begin{verbatim}
		path: git status
		\end{verbatim}

	
		\subsubsection{Visualizzare le differenze} % (fold)
		\label{ssub:visualizzare_le_differenze}
		Per osservare le differenze di un file in relazione a dove si trova:
		% \begin{comment}
			\begin{verbatim}
			# per osservare le modifiche sui file non ancora inseriti
			# nella staging area con quelli presenti su Index
			path: git diff nome_del_file
			# per osservare le modifiche sui file già inseriti nella staging area
			# con quelli presenti su HEAD
			path: git diff --staged nome_del_file
			# per osservare le modifiche sui file nella staging area
			# rispetto a quelli su HEAD
			path: git diff HEAD
			\end{verbatim}
		% \end{comment}

		% subsubsection visualizzare_le_differenze (end)
		
		\subsubsection{Rimuovere i file dalla staging area (reset)} % (fold)
		\label{ssub:rimuovere_i_file_dalla_staging_area}
		Per rimuovere dei file aggiunti nella staging area, tramite il comando \textbf{git add}, bisogna lanciare il seguente comando:
			\begin{verbatim}
			path: git reset HEAD # per rimuovere tutti i file
			path: git reset HEAD nome_del_file # per rimuovere solo quello specificato
			\end{verbatim}
		\noindent
		La variabile Index viene portata indietro di un passo. \newline \newline
		Per annullare l'ultimo commit dobbiamo eseguire il seguente comando:
			\begin{verbatim}
			path: git reset --soft HEAD^
			\end{verbatim}
		\noindent
		L'opzione --\textbf{soft} serve a lasciare i file, dell'ultima commit, nella staging area, quindi puntati dalla variabile Index. \newline
		La direttiva \textbf{HEAD\^} serve per annullare i commit solo fino al penultimo, cioè quello precedente di quello che vogliano annullare. \newline
		La variabile HEAD viene portata indietro di un passo. \newline
		\textbf{Nota}: questi comandi non annullano le modifiche effettuate ai file. \newline \newline
		Per rimuovere l'ultimo commit dobbiamo eseguire il seguente comando:
			\begin{verbatim}
			path: git reset --hard HEAD^
			\end{verbatim}
		\noindent
		Le variabili HEAD, Index e Working Tree vengono portate indietro di un passo. \newline
		Questo comando è potenzialmente dannoso perché rischi di farti perdere il lavoro presente nella Working Tree. \'E bene quindi utilizzarlo solo quando il comando \textbf{git status} da un output pulito. \newline
		Non bisogna inoltre usare questo comando quando il commit è stato pushato in un repository pubblico, perché altri sviluppatori potrebbero fare riferimento ad un istanza che verrebbe rimossa.
		
 		% subsubsection rimuovere_i_file_dalla_staging_area (end)
		
		\subsubsection{Annullare i cambiamenti (checkout)} % (fold)
		\label{ssub:annullare_i_cambiamenti}
		Per riportare i file che si sono modificati, ma non ancora committati, allo stato dell'ultimo commit, bisogna eseguire il seguente comando:
			\begin{verbatim}
			path: git checkout -- nome_del_file
			\end{verbatim}
		% subsubsection annullare_i_cambiamenti (end)

		\subsubsection{Ripristinare precedenti versioni (revert)} % (fold)
		\label{ssub:ripristinare_precedenti_versioni}
		TO DO
		% subsubsection ripristinare_precedenti_versioni (end)


		\subsubsection{Branch} % (fold)
		\label{ssub:branch}
		A differenza di altri sistemi di versionamento, in git un branch è semplicemente un puntatore a un commit. \newline
		Le operazioni di branching sono elencate di seguito:
			\begin{itemize}
				\item creare un branch:
					\begin{verbatim}
					path: git branch nome_del_branch [punto di partenza]
					\end{verbatim}
				\item cancellare un branch:
					\begin{verbatim}
					path: git branch -d|-D nome_del_branch
					\end{verbatim}
				\item muoversi tra i diversi branch:
					\begin{verbatim}
					path: git checkout nome_del_branch_dove_spostarsi
					\end{verbatim}
				Questo comando può essere eseguito solo quando non ci sono file ancora da committare;
				\item creare e spostarsi nel branch appena generato:
					\begin{verbatim}
					path: git checkout -b nome_del_branch
					\end{verbatim}
				\item rinominare un branch:
					\begin{verbatim}
					path: git branch -m nome_del_branch_vecchio nome_del_branch_nuovo
					\end{verbatim}
			\end{itemize}
			\noindent
		TO DO
		% subsubsection branch (end)


		\subsubsection{Tag} % (fold)
		\label{ssub:tag}
		TO DO
		% subsubsection tag (end)
		
	% subsection lavorare_in_locale (end)
	
	\subsection{Lavorare in remoto} % (fold)
	\label{sub:lavorare_in_remoto}
	TO DO
		\subsubsection{Pubblicare un branch} % (fold)
		\label{ssub:pubblicare_un_branch}
		TO DO
		% subsubsection pubblicare_un_branch (end)

		\subsubsection{Pubblicare un tag} % (fold)
		\label{ssub:pubblicare_un_tag}
		TO DO
		% subsubsection pubblicare_un_tag (end)

	% subsection lavorare_in_remoto (end)

% section lavorare_sul_repository (end)

\newpage \clearpage
\section{Tips per velocizzare il lavoro} % (fold)
\label{sec:tips_per_velocizzare_il_lavoro}
Esistono diversi modi per velocizzare l'uso di git, in modo da renderlo meno frustrante e più appetibile durante le attività di sviluppo.
	\subsection{Auto completamento} % (fold)
	\label{sub:auto_completamento}
	Git di base non offre l'auto completamento per i suoi comandi, bisogna ogni volta quindi scriverli per esteso. Seguendo le istruzioni presenti al seguente link: \url{http://code-worrier.com/blog/autocomplete-git/} sarà possibile abilitare questa funzionalità.
	% subsection auto_completamento (end)
	
	\subsection{Alias} % (fold)
	\label{sub:alias}
	Un altro modo più veloce di eseguire i comandi di git, è definendo degli alias per i comandi che utilizziamo maggiormente. Questo può essere fatto nel modo seguente:
	\begin{verbatim}
		# comandi singoli
		path: git config --gloabl alias.nome_alias nome_comando
		# comandi con opzioni
		path: git config --gloabl alias.nome_alias 'nome_comando opzione'
	\end{verbatim}
	% subsection alias (end)

% section tips_per_velocizzare_il_lavoro (end)

\newpage \clearpage
\section{Git Hooks} % (fold)
\label{sec:git_hooks}
TO DO


% section git_hooks (end)




\newpage \clearpage
\section{Workflow} % (fold)
\label{sec:workflow}
In questa sezione vengono illustrati alcuni modelli di sviluppo che si possono adottare, principalmente nei lavori di gruppo, ma anche a livello personale. Ognuno di questi utilizzati git in diverse maniere a seconda delle sue caratteristiche.
	\subsection{Branching Model} % (fold)
	\label{sub:branching_model}
	In riferimento all'articolo presente al link: \newline
	\url{http://nvie.com/posts/a-successful-git-branching-model/}, viene esposto il modello di sviluppo su git basato su diversi branch. \newline
	TO DO
	\begin{figure}[htbp]
		\centering
		\includegraphics[scale=0.4]{images/git_branch_workflow.png}
		\caption{Git - Branch Workflow Model}
		\label{fig:git_branch_workflow_model}
	\end{figure}
	% subsection branching_model (end)
% section workflow (end)


\newpage \clearpage