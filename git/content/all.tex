% =================================================================================================
% File:			all.tex
% Description:	Defiinisce la sezione relativa a ...
% Created:		2015-01-29
% Author:		Tesser Paolo
% Email:		p.tesser921@gmail.com
% =================================================================================================
% Modification History:
% Version		Modifier Date		Change											Author
% 0.0.1 		2015-01-29 			iniziata stesura documento di prova				Tesser Paolo
% =================================================================================================
% 0.0.2			2015-02-02			aggiunta img + migliorata sez. configurazioni	Tesser Paolo
% =================================================================================================
% 0.0.3			2015-02-02			aggiunta sezione per i workflow, da stendere	Tesser Paolo
% =================================================================================================
%


% CONTENUTO DEL CAPITOLO

\section{Introduzione} % (fold)
\label{sec:introduzione}
Git è un sistema di controllo di versione distribuito. \\
\textbf{Distribuito} (DVCS) significa che ogni componente, del gruppo di lavoro, possiede una copia locale completa del repository. \\

\noindent
\textbf{Vantaggi}:
	\begin{itemize}
		\item operazioni di commit più veloci da effettuare;
		\item si riesce a lavorare offline;
		\item ognuno ha in locale un backup del repository.
	\end{itemize}
	\noindent
	\\
La seguente immagine serve per dare un idea generale di come git lavori e tramite quali operazioni di base. Viene mostrato inoltre il rapporto tra la gestione in locale del repository con quello in remoto. Il dettaglio delle operazioni sarà illustrato prevalentemente nella sezione \ref{sec:lavorare_sul_repository}.

	\begin{figure}[htbp]
		\centering
		\includegraphics[scale=1.1]{images/git_local_remote.png}
		\caption{Git - Locale e Remoto}
		\label{fig:git_locale_e_remoto}
	\end{figure}


	\subsection{Informativi} % (fold)
	\label{sub:informativi}
		\begin{itemize}
			\item \textbf{CodeSchool}: \url{www.codeschool.com};
			\item \textbf{CERN - Best Practice}: PDF;
		\end{itemize}
	% subsection informativi (end)

% section introduzione (end)

\newpage \clearpage
\section{Riferimenti} % (fold)
\label{sec:terminologia}
Di seguito viene spiegato attraverso quali nomi git si riferisce a determinati stati del versionamento. \\ \\

\textbf{Riferimenti specifici}:
	\begin{itemize}
		\item \textbf{Working Tree}: è l'insieme di file su cui si sta lavorando non ancora aggiunti alla staging area (vedi sezione \ref{sub:lavorare_in_locale});
		\item \textbf{Index}: è il riferimento ai file pronti per essere committati, quelli aggiunti alla staging area;
		\item \textbf{HEAD}: è il riferimento all'ultimo commit effettuato;
		\item \textbf{d3a7c852d2c789f791b11091894cc71387e562e9}: un valore hash attribuito ad ogni commit;
		\item \textbf{master, feature-eg}: il nome esatto di un branch per riferirsi ad esso;
		\item \textbf{v1.0.0}: il nome di un tag per riferirsi ad esso.
	\end{itemize}
	\noindent
\textbf{Riferimenti relativi}:
	\begin{itemize}
		\item il commit precedente: ref~1 oppure ref^;
		\item il penultimo commit: ref~2 oppure ref^^;
		\item genitori differenti: ref^1. (TO LEARN)
	\end{itemize}

% section terminologia (end)


\newpage \clearpage
\section{Impostare git} % (fold)
\label{sec:impostare_git}
La prima volta che si installa git è buona pratica impostare da subito alcune credenziali. \\
Queste credenziali possono essere impostate su diversi livelli:
	\begin{itemize}
		\item \textbf{global}: valide quindi per tutti i repository dell'utente. Si trovano nel file:
			\begin{center}
				~/.gitconfig
			\end{center}
		\item \textbf{system}: valide per tutti i repository del computer. Si trovano nel file:
			\begin{center}
				/etc/gitconfig
			\end{center}
		\item \textbf{local}: valide solo per il repository dal quale vengono impostate. Si trovano nel file:
			\begin{center}
				.git/config
			\end{center}
	\end{itemize}
Da linea di comando eseguire i seguenti comandi, cambiando l'opzione ``global'' a seconda delle esigenze:
	\begin{verbatim}
	path: git config --global user.name "Nome Cognome"
	path: git config --global user.email mail@mail.com
	path: git config --global color.ui true
	path: git config --global core.editor emacs
	path: git config --global commit.template ~/.gitmessage.txt
	\end{verbatim}

% section impostare_git (end)

\newpage \clearpage
\section{Creare un repository} % (fold)
\label{sec:creare_un_repository}
Un repository può essere creato in locale e usato solo nel computer dell'utente, anche se questo non permetterà un lavoro collaborativo, oppure, dopo la creazione in locale, può essere associato ad un repository creato su un server (o attraverso un servizio di hosting). \\
Per creare un repository su un servizio di hosting basta seguire le istruzione che il sito propone.
	\subsection{Creazione in locale} % (fold)
	\label{sub:creazione_in_locale}
	Di seguito viene illustrata la sequenza di comandi che dovranno essere eseguiti:
		\begin{verbatim}
		path: mkdir nome_repo
		path: cd nome_repo
		path: git init
		\end{verbatim}
	\noindent
	L'ultima istruzione creerà tutti i metadati necessari al repository. Verranno salvati nella cartella nascosta:
		\begin{center}
			nome\_repo/.git/
		\end{center}

	% subsection creazione_in_locale (end)
	
% section creare_un_repository (end)

\newpage \clearpage
\section{Lavorare sul repository} % (fold)
\label{sec:lavorare_sul_repository}

	\subsection{Lavorare in locale} % (fold)
	\label{sub:lavorare_in_locale}
	Le tre azioni che vengono più spesso eseguite quando si lavora in locale sono:
		\begin{itemize}
			\item creare un file;
			\item aggiungerlo alla \textbf{staging area} attraverso il comando:
				\begin{verbatim}
				path: git add nome_del_file.ext
				\end{verbatim}
				\noindent
				La staging area è il luogo dove sono presenti i file pronti per essere committati.
				Se si vogliono aggiungere più file contemporaneamente o solo alcuni, possiamo eseguire in esclusione questi comandi:
					\begin{verbatim}
					path: git add --all # aggiunge tutti i file presenti nella unstaging area
					path: git add <list of file>
					path: git add *.ext
					path: git add dir/
					\end{verbatim}
				\noindent
				\textbf{Buona pratica}, come verrà illustrato di seguito, vuole che i commit siano il più possibile atomici. \'E \textbf{consigliato fortemente} quindi eseguire il comando:
					\begin{verbatim}
					path: git add --patch (o -p)
					\end{verbatim}
				\noindent
				Questo comando permettere di revisionare il codice che si sta aggiungendo, con la possibilità di scartarne delle parti;

			\item committare i cambiamenti attraverso il comando:
				\begin{verbatim}
				path: git commit -m "msg"
				\end{verbatim}
				\noindent
				Quest'ultima operazione può essere effettuata anche senza l'opzione -m, in tal caso la procedura seguirà lo schema illustrato nella sezione TO DO; \\
				Importante e \textbf{obbligatorio} è effettuare commit atomici in quanto se qualcosa andasse storto, per colpa di qualche inserimento sbagliato, sarebbe più facile effettuare una ricerca dell'errore. Inoltre, questa metodologia, permette di dare una descrizione più efficace sul messaggio di cosa si sta facendo e soprattutto meno prolissa in quanto vado ad aggiungere meno cose contemporaneamente. \\
				Il messaggio che viene inserito deve essere di facile interpretazione. Non bisogna scrivere cose generiche o superflue.
				 
		\end{itemize}
	\noindent
	Per osservare i cambiamenti avvenuti dall'ultima operazione di commit basta lanciare il comando:
		\begin{verbatim}
		path: git status
		\end{verbatim}

	
		\subsubsection{Visualizzare le differenze} % (fold)
		\label{ssub:visualizzare_le_differenze}
		Per osservare le differenze di un file in relazione a dove si trova	:
			\begin{verbatim}
			# per osservare le modifiche sui file non ancora inseriti nella staging area con quelli presenti su Index
			path: git diff nome_del_file
			# per osservare le modifiche sui file già inseriti nella staging area con quelli presenti su HEAD
			path: git diff --staged nome_del_file
			# per osservare le modifiche sui file nella staging area rispetto a quelli su HEAD
			path: git diff HEAD
			\end{verbatim}

		% subsubsection visualizzare_le_differenze (end)
		
		\subsubsection{Rimuovere i file dalla staging area} % (fold)
		\label{ssub:rimuovere_i_file_dalla_staging_area}
		Per rimuovere dei file aggiunti nella staging area, tramite il comando \textbf{git add}, bisogna lanciare il seguente comando:
			\begin{verbatim}
			path: git reset HEAD # per rimuovere tutti i file
			path: git reset HEAD nome_del_file # per rimuovere solo quello specificato
			\end{verbatim}
		\noindent
		Le variabili HEAD e Index vengono portate indietro di un passo.
		Per annullare l'ultimo commit dobbiamo eseguire il seguente comando:
			\begin{verbatim}
			path: git reset --soft HEAD^
			\end{verbatim}
		\noindent
		L'opzione --\textbf{soft} serve a lasciare i file, dell'ultima commit, nella staging area. \\
		La direttiva \textbf{HEAD\^} serve per annullare i commit solo fino al penultimo, cioè quello precedente di quello che vogliano annullare. \\
		\textbf{Nota}: questi comandi non annullano le modifiche effettuate ai file.
		
		% subsubsection rimuovere_i_file_dalla_staging_area (end)
		
		\subsubsection{Annullare i cambiamenti} % (fold)
		\label{ssub:annullare_i_cambiamenti}
		Per riportare i file che si sono modificati, ma non ancora committati, allo stato dell'ultimo commit, bisogna eseguire il seguente comando:
			\begin{verbatim}
			path: git checkout -- nome_del_file
			\end{verbatim}
		% subsubsection annullare_i_cambiamenti (end)
	
	% subsection lavorare_in_locale (end)
	
	\subsection{Lavorare in remoto} % (fold)
	\label{sub:lavorare_in_remoto}
	
	% subsection lavorare_in_remoto (end)
% section lavorare_sul_repository (end)

\newpage \clearpage
\section{Git Hooks} % (fold)
\label{sec:git_hooks}
TO DO


% section git_hooks (end)




\newpage \clearpage
\section{Workflow} % (fold)
\label{sec:workflow}
In questa sezione vengono illustrati alcuni modelli di sviluppo che si possono adottare, principalmente nei lavori di gruppo, ma anche a livello personale. Ognuno di questi utilizzati git in diverse maniere a seconda delle sue caratteristiche.
	\subsection{Branching Model} % (fold)
	\label{sub:branching_model}
	In riferimento all'articolo presente al link: \\
	\url{http://nvie.com/posts/a-successful-git-branching-model/}, viene esposto il modello di sviluppo su git basato su diversi branch. \\
	TO DO
	\begin{figure}[htbp]
		\centering
		\includegraphics[scale=0.4]{images/git_branch_workflow.png}
		\caption{Git - Branch Workflow Model}
		\label{fig:git_branch_workflow_model}
	\end{figure}
	% subsection branching_model (end)
% section workflow (end)


\newpage \clearpage