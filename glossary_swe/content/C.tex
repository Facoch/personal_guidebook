% File: c.tex
% Created: 2014-11-07
% Author: Tesser Paolo
% Email: p.tesser921@gmail.com
% 
%
% Modification History
% Version	Modifier Date	Author			Change
% ====================================================================
% 0.0.1		2014-11-07		Tesser-Paolo	inserita sezione
% ====================================================================
% 0.0.2		2015-02-05		Tesser Paolo	inseriti vocaboli: Configurazione
% ====================================================================
% 0.0.3		2015-02-25		Tesser Paolo	inserite voci: CMMI
% ====================================================================
%

\section{C}

	\begin{itemize}
		\item \textbf{Casi d'uso}: [PR] tecnica usata nei processi di ingegneria del software per effettuare in maniera esaustiva e non ambigua, la raccolta dei requisiti al fine di produrre software di qualità. Consiste nel valutare ogni requisito, focalizzandosi sugli attori che interagiscono col sistema e valutandone le varie interazioni. Il documento dei casi d’uso, individua e descrive gli scenari elementari di utilizzo del sistema, da parte degli attori che si inter facciano con esso;

		\item \textbf{Ciclo di Deming}: [QS][QP] vedi anche PDCA, è un modello studiato per il miglioramento continuo della qualità in un’ottica a lungo raggio. Serve per promuovere una cultura della qualità che è tesa al miglioramento continuo dei processi e all’utilizzo ottimale delle risorse. Questo strumento parte dall’assunto che per il raggiungimento del massimo della qualità sia necessaria la costante interazione tra ricerca, progettazione, test, produzione e vendita. \newline
	Per migliorare la qualità e soddisfare il cliente, le quattro fasi devono ruotare costantemente, tenendo come criterio principale la qualità.
	La sequenza logica dei quattro punti ripetuti per un miglioramento continuo è la seguente:
		\begin{itemize}
			\item P: Plan. Pianificazione;
			\item D: Do. Esecuzione del programma, dapprima in contesti circoscritti;
			\item C: Check. Test e controllo, studio e raccolta dei risultati e dei riscontri;
			\item A: Act. Azione per rendere definitivo e/o migliorare il processo.
		\end{itemize}

		\item \textbf{Classi di equivalenza}: [VV][analisi dinamica] servono per raggruppare in astratto valori che per ogni test sono indistinguibili, quindi si può prendere come valore uno solo all'interno della classe per effettuare il test. Ogni categoria di valori è una classe di equivalenza. Ne esistono generalmente 3:
			\begin{enumerate}
				\item valori nominali interni al dominio
				\item valori legali di limite
				\item valori illegali
			\end{enumerate}

		\item \textbf{Classificazione e gestione dei requisiti}: [IS] Per effettuare una ricerca dei requisiti, bisogna procedere in maniera top-down. Quando vengono trovati, l'analista deve anche sapere dire come vengono verificati non ad un elevato costo. A seconda del tipo di requisito possono essere attuate diverse metodologie per verificarli.
			\begin{itemize}
				\item \textbf{Funzionali}: attraverso test, dimostrazione formale o revisione;
				\item \textbf{Prestazionali}: attraverso misurazioni;
				\item \textbf{Qualitativi}: attraverso una verifica ad hoc;
				\item \textbf{Dichiarativi (vincolo)}: attraverso revisione.
			\end{itemize}
			\noindent
		I requisiti hanno inoltre utilità strategica diversa a seconda di quanto siano importanti per gli stakeholder. Vengono quindi divisi in: obbligatori, desiderabili e opzionali. I requisiti non devono mai andare in contrasto tra di loro (Comma 22). Devono essere inoltre tutti e soli quelli ritenuti necessari e sufficienti. \newline
		I requisiti vanno gestiti tramite una base di dati in modo da mantenere più facilmente una struttura gerarchica e univoca, per facilitare poi infine il tracciamento;

		\item \textbf{Closure}: nei linguaggi di programmazione è una astrazione che combina una funzione con le variabili libere presenti nell'ambiente in cui è definita;
		\item \textbf{CMMI}: [QP] Capability Maturity Model Integration:
			\begin{itemize}
				\item \textbf{Capability}: misura di quanto è adeguato un processo per gli scopi per cui è stato definito. Questa metrica considera un processo singolarmente e ne determina l'intorno del risultato raggiungibile utilizzando quel processo;
				\item \textbf{Maturity}: misura di quanto è governato il sistema dei processi dell'azienda. Questa metrica considera un insieme di processi, quelli che rispondono al miglioramento continuo dell'organizzazione. Il risultato viene elaborato dall'effetto combinato delle Capability dei processi coinvolti;
				\item \textbf{Model}: insieme di requisiti via via più stringenti per valutare il percorso di miglioramento dei processi dell'azienda;
				\item \textbf{Integration}: architettura di integrazione delle diverse discipline e tipologie di attività delle azienda.
			\end{itemize}
			\noindent
		Un processo a basso livello di Capability significa che dipende da chi lo attua, viene definito e seguito in maniera opportunistica e ne è difficile prevedere l'esito. Al contrario, se il livello è alto, vuol dire che il processo viene seguito da tutti in modo disciplinato, sistematico e quantificabile. Attraverso questi valori si ottiene un insieme strutturato di elementi che descrivono le caratteristiche di processi efficaci. Con questo modello viene fornita/o/e una base concettuale su cui appoggiarsi, delle best practice dalla comunità di esperti e utilizzatori, un linguaggio comune e un modo per definire che cosa significa miglioramento nell'organizzazione. \newline
		Può essere usato anche per confrontare organizzazioni diverse. \newline
		Vengono perciò definiti 5 livelli di maturità, che si possono scalare applicando attività di management:
			\begin{enumerate}
				\item \textbf{Initial}: il processo è imprevedibile e scarsamente controllato, le informazioni vengono acquisite in pull;
				\item \textbf{Managed}: il processo è principalmente riguardante un progetto, migliora la reattività;
				\item \textbf{Defined}: il processo è trasversale per l'organizzazione ed è pro-attivo;
				\item \textbf{Quantitatively Managed}: il processo è misurato e controllato, fornisce informazioni in push;
				\item \textbf{Optimizing}: l'obiettivo è migliorare il processo già buono.
			\end{enumerate}

		\item \textbf{Common wisdom}: [PROG]
			\begin{itemize}
				\item don't re-invent the wheel
				\item keep things as simple as possible but not simpler
				\item learn from others mistakes, not your own
				\item never forget performance
				\item pursue bug-free code, clean code will follow
				\item begin with an end in mind
				\item first seek to understand, then to be understood
				\item there's a place for everything and everything in its place
				\item always seek scalability
				\item works on basic to fill your knowledge gaps
				\item strive to know and how it is happening
				\item spend time in understanding and analysing the problem and designing soloutions for it
				\item try to break you own code before others can
				\item work-arounds don't work for long
			\end{itemize}

		\item \textbf{Configurazione}: [AM] un prodotto SW è l'unione di parti distinte, tenute insieme secondo regole precise. Queste regole vanno pianificate e necessitano di essere il più possibile automatizzate attraverso appositi strumenti;

		\item \textbf{Controllo di versione}: [AM]  è la gestione di versioni multiple di un insieme di informazioni. I documenti che vengono gestiti attraverso questa tecnica sono tutti quelli che hanno o necessitano di avere una storia.\newline
			Questi strumenti (Git, SVN, Mercurial) ci permettono di muoverci attraverso le varie modifiche che sono state effettuate su file digitali come del codice sorgente, disegni tecnici, documentazione o altro, e, in caso di necessità, ripristinare quelli antecedenti alla versione attuale. \newline
			Tutto ciò serve per correggere errori o ritornare a stati in cui non ce ne erano. Ci permette inoltre di procedere su rami diversi in modo da non entrare in conflitto con sezioni stabili dello sviluppo;

		\item \textbf{Comportamento predicibile}: [VV][analisi statica] è necessario avere un codice sorgente senza ambiguità. Ad esempio deve essere sempre lo stesso l'ordine di elaborazione e di inizializzazione. Oppure la modalità di passaggio dei parametri deve essere ben definita (per valore o per riferimento);

		\item \textbf{Copertura (coverage)}: [VV][analisi dinamica] per ogni test di deve definire l'oggetto, la strategia, le risorse necessarie e il piano di esecuzione. Si ha \textbf{Statement Coverage} al 100 per 100 quando i test effettuati sull'unità sono sufficienti a eseguire almeno una volta tutte le linee di comando di ciascuno dei moduli dell'unità, ciò significa che dovrei fare tanti test quanti sono gli statement, ciò implica che se fisso delle norme per limitare il livello di annidamento consentito, diminuisco anche i test da fare. Si ha invece \textbf{Branch Coverage} al 100 per 100 quando ciascuno ramo del flusso di controllo viene attraversato almeno una volta. \newline
		La statement coverage è meno potente della branch coverage, perché può non tenere conto di alcune condizioni che escludono l'esecuzione di certe parti del codice, in quanto a lei basta percorrerne il più possibile. A volte però neanche la branch coverage è sufficiente, serve quindi utilizzare la \textbf{condition coverage}. Al crescere del numero di condizioni all'interno di una decisione, il numero di test necessario a massimizzare quest'ultima cresce in maniera proibitiva. Il DO-178B richiede allora di massimizzare il \textbf{modified decision condition coverage}, quest'ultimo implica la branche coverage. In pratica è richiesto che tutte le decisioni siano soggette a test e tutti i loro possibili esiti siano effettivamente prodotti;


		\item \textbf{Criteri di programmazione}: [VV][analisi statica] per rendere più facili le attività di verifica è necessario:
			\begin{itemize}
				\item riflettere l'architettura nel codice;
				\item separare le interfacce dall'implementazione;
				\item massimizzare l'incapsulazione (information hiding);
				\item usare tipi specializzati per specificare dati. 
			\end{itemize}

		\item \textbf{Criteri guida}: [VV][analisi dinamica] ci sono alcuni fattori che vanno definiti quali l'\textbf{oggetto della prova}, e in base a quello avrò tipi diversi di test (sistema nel suo complesso, parti di esso o singole unità) e l'\textbf{obiettivo della prova} che sarà definito nel PdQ. Un altro principio da seguire è quello che devo eseguire dei test con l'intento di trovare errori possibili, adottando quindi un atteggiamento utile e non transigente. La provabilità del software va assicurata a monte dello sviluppo e non a valle di esso. Una singola prova non basta. Le prove quindi devono essere ripetibili, esse possono rilevare malfunzionamenti, ma non garantirne l'assenza.

	\end{itemize}